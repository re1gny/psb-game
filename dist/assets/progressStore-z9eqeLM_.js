import{d as H}from"./index-CvYwoJR4.js";function w(e,u){let s;try{s=e()}catch{return}return{getItem:o=>{var t;const l=c=>c===null?null:JSON.parse(c,void 0),h=(t=s.getItem(o))!=null?t:null;return h instanceof Promise?h.then(l):l(h)},setItem:(o,t)=>s.setItem(o,JSON.stringify(t,void 0)),removeItem:o=>s.removeItem(o)}}const R=e=>u=>{try{const s=e(u);return s instanceof Promise?s:{then(a){return R(a)(s)},catch(a){return this}}}catch(s){return{then(a){return this},catch(a){return R(a)(s)}}}},P=(e,u)=>(s,a,o)=>{let t={storage:w(()=>localStorage),partialize:r=>r,version:0,merge:(r,m)=>({...m,...r}),...u},l=!1;const h=new Set,c=new Set;let d=t.storage;if(!d)return e((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${t.name}', the given storage is currently unavailable.`),s(...r)},a,o);const g=()=>{const r=t.partialize({...a()});return d.setItem(t.name,{state:r,version:t.version})},I=o.setState;o.setState=(r,m)=>{I(r,m),g()};const S=e((...r)=>{s(...r),g()},a,o);o.getInitialState=()=>S;let v;const L=()=>{var r,m;if(!d)return;l=!1,h.forEach(n=>{var i;return n((i=a())!=null?i:S)});const f=((m=t.onRehydrateStorage)==null?void 0:m.call(t,(r=a())!=null?r:S))||void 0;return R(d.getItem.bind(d))(t.name).then(n=>{if(n)if(typeof n.version=="number"&&n.version!==t.version){if(t.migrate){const i=t.migrate(n.state,n.version);return i instanceof Promise?i.then(p=>[!0,p]):[!0,i]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,n.state];return[!1,void 0]}).then(n=>{var i;const[p,b]=n;if(v=t.merge(b,(i=a())!=null?i:S),s(v,!0),p)return g()}).then(()=>{f==null||f(v,void 0),v=a(),l=!0,c.forEach(n=>n(v))}).catch(n=>{f==null||f(void 0,n)})};return o.persist={setOptions:r=>{t={...t,...r},r.storage&&(d=r.storage)},clearStorage:()=>{d==null||d.removeItem(t.name)},getOptions:()=>t,rehydrate:()=>L(),hasHydrated:()=>l,onHydrate:r=>(h.add(r),()=>{h.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},t.skipHydration||L(),v||S},_=P,y=3,C=[1,2,3,6,8],E=H()(_((e,u)=>({isPersisted:!1,isRestarted:!1,remainingLives:y,passedLevels:[],availableCharacters:C,usedCharacters:[],shouldShowStartRules:!0,shouldShowPathRules:!0,shouldShowCardsRules:!0,shouldShowLevelHintRules:!0,passLevel:(s,a,o)=>{e(t=>({passedLevels:[...t.passedLevels,s],availableCharacters:[...t.availableCharacters,...o.map(l=>l.id)],usedCharacters:[...t.usedCharacters,...a.map(l=>l.id)]}))},looseLevel:()=>{const s=u().remainingLives;s>0&&e({remainingLives:s-1})},restart:()=>{e({remainingLives:y,passedLevels:[],availableCharacters:C,usedCharacters:[],isRestarted:!0})},applyCardsRules:()=>{e({shouldShowCardsRules:!1})},applyStartRules:()=>{e({shouldShowStartRules:!1})},applyPathRules:()=>{e({shouldShowPathRules:!1})},applyLevelHintRules:()=>{e({shouldShowLevelHintRules:!1})},completeRestart:()=>{e({isRestarted:!1})}}),{name:"progress-storage",storage:w(()=>localStorage),partialize:e=>({remainingLives:e.remainingLives,passedLevels:e.passedLevels,availableCharacters:e.availableCharacters,usedCharacters:e.usedCharacters,shouldShowStartRules:e.shouldShowStartRules,shouldShowCardsRules:e.shouldShowCardsRules,shouldShowPathRules:e.shouldShowPathRules,shouldShowLevelHintRules:e.shouldShowLevelHintRules}),merge:(e,u)=>({...u,...e,isPersisted:!!e})}));export{y as M,E as u};
