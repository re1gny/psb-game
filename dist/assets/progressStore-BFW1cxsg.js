import{d as P}from"./index-DXYiWIwk.js";function I(t,u){let s;try{s=t()}catch{return}return{getItem:n=>{var e;const l=c=>c===null?null:JSON.parse(c,void 0),h=(e=s.getItem(n))!=null?e:null;return h instanceof Promise?h.then(l):l(h)},setItem:(n,e)=>s.setItem(n,JSON.stringify(e,void 0)),removeItem:n=>s.removeItem(n)}}const R=t=>u=>{try{const s=t(u);return s instanceof Promise?s:{then(a){return R(a)(s)},catch(a){return this}}}catch(s){return{then(a){return this},catch(a){return R(a)(s)}}}},_=(t,u)=>(s,a,n)=>{let e={storage:I(()=>localStorage),partialize:r=>r,version:0,merge:(r,m)=>({...m,...r}),...u},l=!1;const h=new Set,c=new Set;let d=e.storage;if(!d)return t((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),s(...r)},a,n);const g=()=>{const r=e.partialize({...a()});return d.setItem(e.name,{state:r,version:e.version})},w=n.setState;n.setState=(r,m)=>{w(r,m),g()};const f=t((...r)=>{s(...r),g()},a,n);n.getInitialState=()=>f;let v;const C=()=>{var r,m;if(!d)return;l=!1,h.forEach(o=>{var i;return o((i=a())!=null?i:f)});const S=((m=e.onRehydrateStorage)==null?void 0:m.call(e,(r=a())!=null?r:f))||void 0;return R(d.getItem.bind(d))(e.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==e.version){if(e.migrate){const i=e.migrate(o.state,o.version);return i instanceof Promise?i.then(p=>[!0,p]):[!0,i]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var i;const[p,b]=o;if(v=e.merge(b,(i=a())!=null?i:f),s(v,!0),p)return g()}).then(()=>{S==null||S(v,void 0),v=a(),l=!0,c.forEach(o=>o(v))}).catch(o=>{S==null||S(void 0,o)})};return n.persist={setOptions:r=>{e={...e,...r},r.storage&&(d=r.storage)},clearStorage:()=>{d==null||d.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>C(),hasHydrated:()=>l,onHydrate:r=>(h.add(r),()=>{h.delete(r)}),onFinishHydration:r=>(c.add(r),()=>{c.delete(r)})},e.skipHydration||C(),v||f},A=_,L=3,y=[1,2,3,6,8],E=P()(A((t,u)=>({isPersisted:!1,isRestarted:!1,remainingLives:L,passedLevels:[],availableCharacters:y,usedCharacters:[],shouldShowStartRules:!0,shouldShowPathRules:!0,shouldShowCardsRules:!0,passLevel:(s,a,n)=>{t(e=>({passedLevels:[...e.passedLevels,s],availableCharacters:[...e.availableCharacters,...n.map(l=>l.id)],usedCharacters:[...e.usedCharacters,...a.map(l=>l.id)]}))},looseLevel:()=>{const s=u().remainingLives;s>0&&t({remainingLives:s-1})},restart:()=>{t({remainingLives:L,passedLevels:[],availableCharacters:y,usedCharacters:[],isRestarted:!0})},applyCardsRules:()=>{t({shouldShowCardsRules:!1})},applyStartRules:()=>{t({shouldShowStartRules:!1})},applyPathRules:()=>{t({shouldShowPathRules:!1})},completeRestart:()=>{t({isRestarted:!1})}}),{name:"progress-storage",storage:I(()=>localStorage),partialize:t=>({remainingLives:t.remainingLives,passedLevels:t.passedLevels,availableCharacters:t.availableCharacters,usedCharacters:t.usedCharacters,shouldShowStartRules:t.shouldShowStartRules,shouldShowCardsRules:t.shouldShowCardsRules,shouldShowPathRules:t.shouldShowPathRules}),merge:(t,u)=>({...u,...t,isPersisted:!!t})}));export{L as M,E as u};
